{
  "version": "1.0",
  "project": "Logistic Intel – plan endpoint + CRM resolver",
  "goal": "Expose user plan + entitlements for UI gating and add a robust company resolver (company_name→company_id) used by the CRM add flow, with dedupe and policy-safe inserts.",
  "instructions": [
    {
      "type": "fs.write",
      "path": "supabase/migrations/2025-08-08_plan_fn_and_crm_fixes.sql",
      "overwrite": true,
      "content": "-- === PLAN FN + CRM FIXES ===\n-- 1) Helper: get_user_plan(auth.uid())\nCREATE OR REPLACE FUNCTION public.get_user_plan(p_uid uuid)\nRETURNS text\nLANGUAGE sql STABLE AS $$\n  SELECT COALESCE(up.plan, (u.raw_user_meta_data->>'plan'))::text\n  FROM auth.users u\n  LEFT JOIN public.user_profiles up ON up.id = u.id\n  WHERE u.id = p_uid\n$$;\n\n-- 2) Companies: optional normalization helpers + uniqueness guard (within tenant/adder)\nCREATE OR REPLACE FUNCTION public.norm_text(t text) RETURNS text\nLANGUAGE sql IMMUTABLE AS $$\n  SELECT CASE WHEN t IS NULL THEN NULL ELSE trim(regexp_replace(lower(t), '\\\\s+', ' ', 'g')) END;\n$$;\n\n-- Add missing columns (guarded)\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.columns \n    WHERE table_schema='public' AND table_name='companies' AND column_name='added_by_user'\n  ) THEN\n    ALTER TABLE public.companies ADD COLUMN added_by_user uuid REFERENCES auth.users(id);\n  END IF;\nEND $$;\n\n-- Scoped uniqueness per user (company_name+country per tenant)\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_indexes WHERE schemaname='public' AND indexname='uq_companies_name_country_by_user'\n  ) THEN\n    CREATE UNIQUE INDEX uq_companies_name_country_by_user\n    ON public.companies (norm_text(company_name), norm_text(country), added_by_user)\n    WHERE company_name IS NOT NULL;\n  END IF;\nEND $$;\n\n-- 3) CRM contacts: ensure company_id exists and email uniqueness scoped by company\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.columns \n    WHERE table_schema='public' AND table_name='crm_contacts' AND column_name='company_id'\n  ) THEN\n    ALTER TABLE public.crm_contacts ADD COLUMN company_id uuid REFERENCES public.companies(id) ON DELETE CASCADE;\n  END IF;\nEND $$;\n\nDO $$ BEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint WHERE conname='uq_crm_company_email'\n  ) THEN\n    ALTER TABLE public.crm_contacts\n    ADD CONSTRAINT uq_crm_company_email UNIQUE (company_id, email);\n  END IF;\nEND $$;\n\n-- 4) RLS sanity: allow users to manage their own companies/contacts, admins full access\nALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.crm_contacts ENABLE ROW LEVEL SECURITY;\n\nDO $$ BEGIN\n  EXECUTE 'DROP POLICY IF EXISTS companies_user_rw ON public.companies';\n  EXECUTE 'DROP POLICY IF EXISTS companies_admin_all ON public.companies';\n  EXECUTE 'DROP POLICY IF EXISTS crm_user_rw ON public.crm_contacts';\n  EXECUTE 'DROP POLICY IF EXISTS crm_admin_all ON public.crm_contacts';\nEXCEPTION WHEN OTHERS THEN NULL; END $$;\n\nCREATE POLICY companies_user_rw ON public.companies\n  FOR ALL USING (added_by_user = auth.uid())\n  WITH CHECK (added_by_user = auth.uid());\n\nCREATE POLICY companies_admin_all ON public.companies\n  FOR ALL USING (EXISTS (\n    SELECT 1 FROM auth.users u WHERE u.id = auth.uid() AND (u.raw_user_meta_data->>'role')='admin'\n  ));\n\nCREATE POLICY crm_user_rw ON public.crm_contacts\n  FOR ALL USING (added_by_user = auth.uid())\n  WITH CHECK (added_by_user = auth.uid());\n\nCREATE POLICY crm_admin_all ON public.crm_contacts\n  FOR ALL USING (EXISTS (\n    SELECT 1 FROM auth.users u WHERE u.id = auth.uid() AND (u.raw_user_meta_data->>'role')='admin'\n  ));\n"
    },
    {
      "type": "fs.write",
      "path": "src/app/api/me/plan/route.ts",
      "overwrite": true,
      "content": "import { NextResponse } from 'next/server';\nimport { supabaseServer } from '@/lib/supabase-server';\nexport const runtime = 'nodejs';\nexport const dynamic = 'force-dynamic';\n\ntype Plan = 'trial'|'starter'|'pro'|'enterprise';\nconst ENTITLEMENTS: Record<Plan, any> = {\n  trial:      { companies: 100,  modes: { ocean: true, air: false }, contacts: false, export: false },\n  starter:    { companies: 1000, modes: { ocean: true, air: false }, contacts: false, export: true  },\n  pro:        { companies: 10000,modes: { ocean: true, air: true  }, contacts: true,  export: true  },\n  enterprise: { companies: Infinity, modes: { ocean: true, air: true }, contacts: true,  export: true }\n};\n\nexport async function GET(){\n  const s = supabaseServer();\n  const { data: { user } } = await s.auth.getUser();\n  if (!user) return NextResponse.json({ success:false, error:'Not authenticated' }, { status: 401 });\n\n  let plan: Plan = 'trial';\n  try {\n    const { data } = await s.rpc('get_user_plan', { p_uid: user.id });\n    const p = (Array.isArray(data) ? data[0] : data) as string | null;\n    if (p && ['trial','starter','pro','enterprise'].includes(p)) plan = p as Plan;\n  } catch {}\n\n  return NextResponse.json({ success:true, plan, entitlements: ENTITLEMENTS[plan] });\n}\n"
    },
    {
      "type": "fs.write",
      "path": "src/app/api/crm/resolve-company/route.ts",
      "overwrite": true,
      "content": "import { NextResponse } from 'next/server';\nimport { supabaseServer } from '@/lib/supabase-server';\nexport const runtime='nodejs'; export const dynamic='force-dynamic';\n\nfunction norm(t?:string|null){ return t? t.toLowerCase().trim().replace(/\\s+/g,' ') : null; }\n\nexport async function POST(req: Request){\n  const s = supabaseServer();\n  const { data: { user } } = await s.auth.getUser();\n  if (!user) return NextResponse.json({ success:false, error:'Not authenticated' }, { status: 401 });\n  const body = await req.json().catch(()=>({}));\n  const company_name = body.company_name as string | undefined;\n  if (!company_name || !company_name.trim()) return NextResponse.json({ success:false, error:'company_name required' }, { status: 400 });\n  const country = body.country as string | undefined;\n  const industry = body.industry as string | undefined;\n\n  const nameN = norm(company_name);\n  const countryN = norm(country||'');\n\n  // Try find existing for this user (RLS scoped)\n  const { data: existing } = await s.from('companies')\n    .select('id, company_name, country')\n    .eq('added_by_user', user.id)\n    .ilike('company_name', company_name)\n    .maybeSingle();\n\n  if (existing?.id) return NextResponse.json({ success:true, company_id: existing.id, company: existing });\n\n  // Insert new\n  const insert = {\n    company_name: company_name.trim(),\n    country: country || null,\n    industry: industry || null,\n    added_by_user: user.id\n  } as any;\n\n  const { data, error } = await s.from('companies').insert(insert).select('id, company_name, country').single();\n  if (error) return NextResponse.json({ success:false, error: error.message }, { status: 400 });\n  return NextResponse.json({ success:true, company_id: data.id, company: data });\n}\n"
    },
    {
      "type": "fs.write",
      "path": "src/app/api/crm/contacts/route.ts",
      "overwrite": true,
      "content": "import { NextResponse } from 'next/server';\nimport { supabaseServer } from '@/lib/supabase-server';\nexport const runtime='nodejs'; export const dynamic='force-dynamic';\n\nexport async function POST(req: Request){\n  const s = supabaseServer();\n  const { data: { user } } = await s.auth.getUser();\n  if (!user) return NextResponse.json({ success:false, error:'Not authenticated' }, { status: 401 });\n  const body = await req.json().catch(()=>({}));\n\n  // Required inputs from callers\n  const company_name = body.company_name as string | undefined;\n  const email = body.email as string | undefined;\n  const full_name = body.contact_name || body.full_name || null;\n  const phone = body.phone || null;\n  const title = body.title || null;\n  const hs_code = body.hs_code || null;\n  const notes = body.notes || null;\n\n  if (!company_name) return NextResponse.json({ success:false, error:'company_name required' }, { status: 400 });\n\n  // Resolve company_id (scoped to current user via RLS)\n  const res = await fetch(new URL('/api/crm/resolve-company', process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'), {\n    method:'POST', headers:{'Content-Type':'application/json'},\n    body: JSON.stringify({ company_name, country: body.country||null, industry: body.industry||null })\n  });\n  const rj = await res.json();\n  if (!rj.success) return NextResponse.json({ success:false, error: rj.error||'resolve failed' }, { status: 400 });\n\n  const insert = {\n    company_id: rj.company_id,\n    full_name,\n    email: email || null,\n    phone,\n    title,\n    added_by_user: user.id,\n    notes,\n    hs_code,\n    created_at: new Date().toISOString()\n  } as any;\n\n  const { data, error } = await s.from('crm_contacts').insert(insert).select('id, company_id, full_name, email');\n  if (error) {\n    if (error.message.toLowerCase().includes('duplicate key'))\n      return NextResponse.json({ success:false, error:'Contact already exists in CRM' }, { status: 409 });\n    return NextResponse.json({ success:false, error: error.message }, { status: 400 });\n  }\n\n  return NextResponse.json({ success:true, contact: Array.isArray(data)?data[0]:data });\n}\n"
    },
    {
      "type": "fs.write",
      "path": "docs/patches/plan_and_crm.md",
      "overwrite": true,
      "content": "## Frontend wiring\n\n1) Fetch plan once and gate features\n```ts\nuseEffect(()=>{(async()=>{\n  const r = await fetch('/api/me/plan',{cache:'no-store'}); const j = await r.json();\n  if (j.success) {\n    setUserPlan(j.plan); // 'trial'|'starter'|'pro'|'enterprise'\n    setEntitlements(j.entitlements); // modes, companies, contacts, export\n  }\n})();},[]);\n```\n\n2) Add-to-CRM call\nKeep your existing call to `/api/crm/contacts`. It now auto-resolves `company_id` from `company_name` and enforces RLS:\n```ts\nawait fetch('/api/crm/contacts', {\n  method: 'POST', headers: {'Content-Type':'application/json'},\n  body: JSON.stringify({\n    company_name: record.unified_company_name,\n    full_name: record.contact_person,\n    email: record.primary_email,\n    phone: record.primary_phone,\n    title: record.title,\n    hs_code: record.hs_code,\n    notes: 'Added from Trade Search'\n  })\n});\n```\n\n3) Search gating\nIf `entitlements.modes.air` is `false`, disable Air mode toggle and filter server queries accordingly.\n"
    }
  ]
}